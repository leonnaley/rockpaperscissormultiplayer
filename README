rockpaperscissor is a simple rock paper scissor game with networking.

I'm making this to learn networking, advanced unittesting, guicreating, etc...

The first implementation will support multiple players on different computers,
and options for playing with computers.

the second version will support hotseating and ai

the third version will implement a gui

If adding files to this project please use template.py as a template.


DOCUMENTATION
    DEBUGGING
        If you want to debug this program, just append -debug as the parameters
        when running this program, the error will be printed and you will find
        yourself in interactive mode at where the error occurred.
    LOGGING
        Logging in this program uses the builtin python system.
        Whenever you want to use logging, logging.debug("This text will be
        logged)

        You can change the it from the debug level to something more severe
        if you would like, anything from the level ERROR or worse will be
        logged automatically.

        Remember to run this program with the parameter -log
        to turn on logging.

        To log to a file, add: filename='log.txt' as parameters
        into the basicconfig line in the logging part of libcommon
    UNITTESTING
        Unittesting is strongly encouraged and is implemented by the
        standard python library unittest.

        Do not remove any "old" unit tests unless you know what you are doing.

        all unit tests are located in the unittests.py
        This file will be split up to test all the modules in its folder.
    NAMING OF FUNCTIONS, VARIABLES, OBJECTS, ETC...
        The naming system used is CamelBack, so every word for variables and
        whatnot starts with a capital letter to make reading easier.

        Every variable/object/classes/etc.. are also prefixed with one or more
        lowercase identifiers so you can easily determine the type.
        Examples: iMyInteger, sMyString

        If the type is a container (lists/tuples/sets/etc..)
        the first letter will determine the container type and the second one
        will determine what type it holds.
        Examples: liMyListOfIntegers, tfMyTupleOfFloats

        If the type is a function or method that returns something.
        the first letter will determine if it's a function or a method and
        the second one will determine what type it holds.
        Examples: fiMyFunctionReturnsAnInteger, mfMyMethodReturnsAFloat

        if there are functions returning containers or containers containing
        containers use common sense for when to stop prefixing.

        COMMON PREFIXES
            b       = boolean
            c       = class
            d       = dictionary
            i       = integer/bytes/floats
            o       = object
            ofile   = fileobject (a file)
            s       = string
            x       = unknown type or the type changes from time to time.
        CONTAINER PREFIXES
            l       = list
            t       = tuples
            z       = sets
        FUNCTION/METHODS PREFIXES
            f       = functions
            m       = methods'''